{"version":3,"sources":["../lib/index.js"],"names":["checkRules","rules","forEach","rule","Error","value","checkSet","set","constructor","global","Set","_originalAdd","prototype","add","rulesFct","call","originalHas","has","resolve","obj","circ","_originalSet","fctObj","fctStr","String","replace","refs","Object","getOwnPropertyNames","map","key","isArray","Array","el","copy","sort","a","b","localeCompare","valType","iterator","values","element","next","elType","setCompare","equal","sortedElmnt","sortedValue","JSON","stringify","toArray","self","out","length","size","count","any","isSupersetOf","isSubsetOf","isProperSupersetOf","properSupersetOf","isProperSubsetOf","properSubsetOf","ExtendedSet","elements","original","from","args","toSet","c","union","set3","intersect","arg","every","compare","difference","set1","set2","complement","symDiff","addToSet","source","target","symmetricDifference","shift","cartesian","cartesianProduct","value1","value2","addToSubset","e","T","X","subsets","S","PT","PTe","powerSet","subs","power","mergeRules","passed","some","mergeRulesStrict"],"mappings":"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","sourcesContent":["// //////////////////////////////////////////////////////////////////////////////// //\n// MIT License\n//\n// Copyright (c) 2018 Jan Küster\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n//   The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n// //////////////////////////////////////////////////////////////////////////////// //\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// INTERNAL                                                                         //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * @private\n */\nfunction checkRules (rules) {\n  rules.forEach(rule => {\n    if (typeof rule !== 'function') {\n      throw new Error(`Expected [rule] to be typeof [function], got [${typeof value}]`)\n    }\n  })\n  return true\n}\n\n/**\n * @private\n */\nfunction checkSet (set) {\n  if (!set || !set.constructor || !(set instanceof global.Set)) {\n    throw new Error(`Expected [set] to be instanceof [Set], got [${set && set.constructor}]`)\n  }\n  return true\n}\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// OVERRIDES                                                                        //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * The original add function.\n * @private\n */\nconst _originalAdd = global.Set.prototype.add\n\n/**\n * Adds a value to the set. If the set already contains the value, nothing happens.\n * Overrides Set.prototype.add.\n * @name Set.prototype.add\n * @function\n * @throws Error if rules function exists and {value} failed the rules check.\n * @param value {*}- Required. Any arbitrary value to be added to the set.\n * @returns {Set} the Set object\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add\n */\nfunction add (value) {\n  if (this.rulesFct && !this.rulesFct.call(null, value)) {\n    throw new Error(`Value [${value}] does not match ruleset.`)\n  }\n  return _originalAdd.call(this, value)\n}\n\nglobal.Set.prototype.add = add\n\n/**\n * The original has function reference.\n * @private\n */\nconst originalHas = global.Set.prototype.has\n\n/**\n * Resolves an element's inner structure to make it comparable by JSON.stringify.\n * @private\n */\nfunction resolve (obj, circ = new _originalSet([obj])) {\n  if (typeof obj === 'undefined' ||\n    typeof obj === 'string' ||\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    obj === null) {\n    return obj\n  }\n\n  if (typeof obj === 'function') {\n    const fctObj = { fctStr: String(obj).replace(/\\s+/g, '') } // function body to string\n    // resolve all function properties / attached references\n    fctObj.refs = Object.getOwnPropertyNames(obj).map(key => originalHas.call(circ, obj[key]) ? 'circular' : resolve(obj[key], circ))\n    return fctObj\n  }\n\n  const isArray = Array.isArray(obj)\n  if (typeof obj !== 'object' && !isArray) {\n    return obj\n  }\n\n  // add obj to check for\n  // circular references\n  circ.add(obj)\n\n  if (isArray) {\n    return obj.map(el => originalHas.call(circ, el) ? 'circular' : resolve(el, circ))\n  }\n\n  const copy = {}\n  Object.getOwnPropertyNames(obj)\n    .sort((a, b) => a.localeCompare(b))\n    .forEach(key => {\n      copy[key] = originalHas.call(circ, obj[key]) ? 'circular' : resolve(obj[key], circ)\n    })\n  return copy\n}\n\n/**\n * Checks if the current set instance contains a given value by recursive deep compare.\n * Overrides the original Set.prototype.has.\n * The check is recursive and respects\n * <ul>\n *   <li>primitive types</li>\n *   <li>complex types, such as Objects or Arrays</li>\n *   <li>nested Objects and cyclic references</li>\n *   <li>functions</li>\n *   <li>functions with properties attached</li>\n *   <li>sets, sets of sets</li>\n * </ul>\n *\n * Note, that functions will be checked against their whitespace-trimmed bodies, which can return false negatives,\n * if for example a comment is added to the compare function that not exists in the original function.\n *\n * @function\n * @name Set.prototype.has\n * @example\n * const a = Set.from({ a:true, b:false })\n * a.has({ b:false, a:true })  // true\n * a.has({ b:false, a:false }) // false\n * @param value {*} - The value to be checked.\n * @returns {boolean} - True, if the value is contained by the set. False, if otherwise.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has\n */\nglobal.Set.prototype.has = function has (value) {\n  const valType = typeof value\n  if (valType === 'string' || valType === 'number' || valType === 'boolean') {\n    return originalHas.call(this, value)\n  }\n\n  const iterator = this.values()\n  let element\n  while ((element = iterator.next().value) !== void 0) {\n    const elType = typeof element\n\n    if (elType !== valType) {\n      return false\n    }\n\n    const setCompare = (element instanceof Set && value instanceof Set)\n\n    // if both point to the same reference\n    if (element === value) {\n      return true\n    } else\n\n    // if we want to check if this set has a set with the\n    // same elements as the given set in the argument,\n    // we need to check for equality of all elements of this set\n    // and the argument set\n    if (setCompare && element.equal(value)) {\n      return true\n    } else\n\n    // - if we want to check if ordered pairs (represented as arrays),\n    //   are equal, we resolve their children and compare their strings.\n    // - For all nested objects we recursively create a \"sorted\"\n    //   version of both and compare their strings.\n    // - functions are string-ed and their properties are resolved\n    //   like objects\n    if ((elType === 'function' && valType === 'function') ||\n      (!setCompare && elType === 'object' && valType === 'object') ||\n      (Array.isArray(element) && Array.isArray(value))) {\n      const sortedElmnt = resolve(element)\n      const sortedValue = resolve(value)\n\n      if (JSON.stringify(sortedElmnt) === JSON.stringify(sortedValue)) {\n        return true\n      }\n    }\n  }\n\n  // and if nothing has matched, we assume\n  // that it is not contained in this set\n  return false\n}\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// PROTOTYPES                                                                       //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * Pass a function that dictates the rules for elements to be part of this set.\n * Use without args to get the current rules function.\n * <br>\n * A rules function needs to fulfill the following requirements:\n * <ul>\n *   <li>Obtain a single element as argument</li>\n *   <li>Check, if that element passes certain conditions</li>\n *   <li>Return false if the element fails any condition</li>\n *   <li>Otherwise return true</li>\n * </ul>\n * <br>\n * If a set contains a rules function (or a merge of many rules functions), the element will only be added to the set,\n * if it passes the rules check.\n * @function\n * @name Set.prototype.rules\n * @example\n * const isInt = n => Number.isInteger(n)\n * const integers = Set.from()\n * integers.rules(isInt)\n * integers.add(1)   // OK, no error\n * integers.add(1.5) // throws error!\n * integers.add(1.0) // OK, because 1.0 === 1 in JS Number\n * @param value {Function} (Optional) a Function that obtains a single argument and returns either a truthy or falsey value.\n * @returns {Function|undefined} Returns the current rules Function or undefined if there is on rules function assigned.\n */\nfunction rules (value) {\n  if (value) {\n    checkRules([value])\n    this.rulesFct = value\n  }\n  return this.rulesFct\n}\n\nglobal.Set.prototype.rules = rules\n\n/**\n * Creates an (unsorted) array from all elements of this set.\n * @function\n * @name Set.prototype.toArray\n * @example new Set([1, 2, 3, 4]).toArray() // [ 1, 2, 3, 4 ]\n * @returns {Array} Array containing all elements of this set in unsorted order.\n */\nfunction toArray () {\n  const self = this\n  const out = []\n  out.length = self.size\n  let count = 0\n  self.forEach(value => {\n    out[count++] = value\n  })\n  return out\n}\n\nglobal.Set.prototype.toArray = toArray\n\n/**\n * Returns an arbitrary element of this collection.\n * Basically the first element, retrieved by iterator.next().value will be used.\n * @function\n * @name Set.prototype.any\n * @returns {*} An arbitrary element of the current set that could by of any type, depending on the elements of the set.\n */\nfunction any () {\n  const self = this\n  const iterator = self.values()\n  return iterator.next().value\n}\n\nglobal.Set.prototype.any = any\n\n/**\n * Checks, whether the current set (this) is a superset of the given set.\n * A set A is superset of set B, if A contains all elements of B.\n * <br>\n * Expression: <code>A ⊇ B</code>\n * @function\n * @name Set.prototype.isSupersetOf\n * @example\n * const a = Set.from(1,2,3,4)\n * const b = Set.from(1,2,3)\n * const c = Set.from(1,2,3,4,5)\n * a.isSupersetOf(b) // true\n * a.isSupersetOf(c) // false\n * c.isSupersetOf(b) // true\n * @param set {Set} - A set instance of which this set is checked to be the superset.\n * @throws Throws an error, if the given set is not a set instance.\n * @returns {boolean} true if this set is the superset of the given set, otherwise false.\n * @see https://en.wikipedia.org/wiki/Subset\n */\nfunction isSupersetOf (set) {\n  const iterator = set.values()\n  let value\n  while ((value = iterator.next().value) !== void 0) {\n    if (!this.has(value)) return false\n  }\n  return true\n}\n\nglobal.Set.prototype.isSupersetOf = isSupersetOf\n\n/**\n * Checks, whether the current set (this) is a subset of the given set.\n * A set A is subset of set B, if B contains all elements of A.\n * <br>\n * Expression: <code>A ⊆ B</code>\n * <br>\n * If their sizes are also equal, they can be assumed as equal.\n * If their sizes are not equal, then A is called a proper subset of B.\n * @function\n * @name Set.prototype.isSubsetOf\n * @example\n * const a = Set.from(1,2,3,4)\n * const b = Set.from(1,2,3)\n * const c = Set.from(1,2,3,4,5)\n * a.isSubsetOf(b) // false\n * b.isSubsetOf(c) // true\n * c.isSubsetOf(a) // false\n * @param set {Set} - A set instance of which this set is checked to be the subset.\n * @throws Throws an error, if the given set is not a set instance.\n * @returns {boolean} - true if this set is the subset of the given set, false otherwise\n * @see https://en.wikipedia.org/wiki/Subset\n * @see Set.prototype.equal\n * @see Set.prototype.isProperSubsetOf\n */\nfunction isSubsetOf (set) {\n  return set.isSupersetOf(this)\n}\n\nglobal.Set.prototype.isSubsetOf = isSubsetOf\n\n/**\n * Checks, whether the current set (this) is a proper superset of the given set.\n * A set A is a proper subset of set B, if A contains all elements of B and their sizes are not equal.\n * <br>\n * Expression: <code>A ⊃ B</code>\n * @function\n * @name Set.prototype.properSupersetOf\n * @param set {Set} - A set instance of which this set is checked to be the proper superset.\n * @returns {boolean}\n * @see https://en.wikipedia.org/wiki/Subset\n */\nfunction isProperSupersetOf (set) {\n  return this.size !== set.size && this.isSupersetOf(set)\n}\n\nglobal.Set.prototype.properSupersetOf = isProperSupersetOf\n\n/**\n * Checks, whether the current set (this) is a proper subset of the given set.\n * A set A is a proper subset of set B, if B contains all elements of A and their sizes are not equal.\n * <br>\n * Expression: <code>A ⊂ B</code>\n * @function\n * @name Set.prototype.properSupersetOf\n * @param set {Set} - A set instance of which this set is checked to be the proper subset.\n * @returns {boolean}\n * @see https://en.wikipedia.org/wiki/Subset\n */\nfunction isProperSubsetOf (set) {\n  return this.size !== set.size && this.isSubsetOf(set)\n}\n\nglobal.Set.prototype.properSubsetOf = isProperSubsetOf\n\n/**\n * Checks, whether two sets are equal in terms of their contained elements.\n * Note: This implementation uses a deep object comparison in order to check for \"sameness\".\n * This allows also to check equality for more complex / nested structures without the restriction of interpreting\n * \"sameness\" as \"being the exact same instance\". If such an equality is desired, please use Set.prototype.equalSrict\n * @function\n * @name Set.prototype.equal\n * @example\n * const a = Set.from(1,2,3)\n * const b = Set.from(1,2,3.0) // note that 3.0 will evaluate to 3 here!\n * a === b    // false\n * a.equal(b) // true\n * @example\n * const a = Set.from({ a:true, b:false })\n * const b = Set.from({ b:false, a:true })\n * a.equal(b) // true\n * @param set {Set} - A set instance, which this set is to be compared with.\n * @throws Throws an error if the given paramter is not a Set instance.\n * @returns {boolean} true, if all elements of this set equal to the elements of the given set.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness\n * @see Set.prototype.isSubsetOf\n */\nfunction equal (set) {\n  checkSet(set)\n  if (this.size !== set.size) {\n    return false\n  }\n  return this.isSubsetOf(set)\n}\n\nglobal.Set.prototype.equal = equal\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// CONSTRUCTOR                                                                      //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * The original Set reference.\n * @private\n */\nconst _originalSet = global.Set\n\n/**\n * Use <code>new Set(elements, rulesFct)</code> to create new sets. Alternatively you can use <code>Set.from</code>\n * @class\n * @name Set\n * @classdesc Extended version of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">Set (MDN link)</a>\n * @param elements {array} - an Array of element.\n * @param rulesFct {function} - a function which every element added to the set needs to pass.\n * @see Set.from\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n * @returns {Set} An instance of the extended version of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">Set (MDN link)</a>\n */\nfunction ExtendedSet (elements, rulesFct) {\n  const original = new _originalSet()\n  if (rulesFct) {\n    original.rules(rulesFct)\n  }\n  if (elements) { elements.forEach(element => original.add(element)) }\n  return original\n}\n\nglobal.Set = ExtendedSet\nglobal.Set.prototype = _originalSet.prototype\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// STATICS                                                                          //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * Creates a new Set from arbitrary arguments without the need of \"new\" and the array notation.\n * @function\n * @name Set.from\n * @example Set.from(1,2,3,4,5) // returns Set { 1, 2, 3, 4, 5 }\n * @example\n * const ints = Set.from(1,2,3)\n * const flts = Set.from(4.5, 5.6, 6.7)\n * Set.from(ints, flts) // returns Set { Set {1, 2, 3}, Set { 4.5, 5.6, 6.7 } }\n * @param args {...*} - values of any types / length (using comma notation or spread operator)\n * @returns {Set} A set containing the given argument values.\n */\nfunction from (...args) {\n  return new Set([...args])\n}\n\nglobal.Set.from = from\n\n/**\n * Autowraps a value to a Set, unless it is already a Set.\n * @function\n * @name Set.toSet\n * @param value  {*} - Any arbitrary value\n * @returns {Set} A Set containing the value or the value if it is already a Set.\n */\nfunction toSet (value) {\n  return value instanceof Set ? value : Set.from(value)\n}\n\nglobal.Set.toSet = toSet\n\n/**\n * Copies all elements of a given Set instance into a new Set and returns it.\n * <strong>It does not deep-clone the elements of the set.</strong>\n * @function\n * @name Set.copy\n * @throws Throws an error if the argument is not a Set instance.\n * @param set {Set} a set instance from which to copy from\n * @returns {Set} a new Set instance containing all elements of the source.\n */\nfunction copy (set) {\n  checkSet(set)\n  const c = new Set()\n  set.forEach(el => c.add(el))\n  return c\n}\n\nglobal.Set.copy = copy\n\n/**\n * Creates a unified set of an arbitrary number of sets.\n * A union of A and B is a set containing all elements of A and B.\n * <br>Expression: <code>C = A ∪ B</code>\n * <br>Example: <code>{1,2} ∪ {2,3,4} = {1,2,3,4}</code>\n * @name Set.union\n * @function\n * @param args {...Set} - an arbitrary list of Set instances\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @returns {Set} a Set instance with the unified elements of the given args.\n * @see https://en.wikipedia.org/wiki/Union_(set_theory)\n */\nfunction union (...args) {\n  const set3 = new Set()\n  args.forEach(set => checkSet(set) && set.forEach(value => set3.add(value)))\n  return set3\n}\n\nglobal.Set.union = union\n\n/**\n * Creates an intersection set of an arbitrary number of sets.\n * An intersection is a set of A and B, which contains all elements that appear in A, as well as in B.\n * <br>\n * Expression: <code>C = A ∩ B</code>\n * <br>\n * Example: <code>{1, 2, 3} ∩ {2, 3, 4} = {2, 3}.</code>\n * @name Set.intersect\n * @function\n * @param args {...Set}- an arbitrary list of Set instances\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @returns {Set} a Set instance with the unified elements of the given args.\n * @see https://en.wikipedia.org/wiki/Intersection_(set_theory)\n */\nfunction intersect (...args) {\n  args.forEach(arg => checkSet(arg))\n  const set3 = new Set([])\n  args.forEach(set => {\n    set.forEach(value => {\n      if (args.every(compare => compare.has(value))) {\n        set3.add(value)\n      }\n    })\n  })\n  return set3\n}\n\nglobal.Set.intersect = intersect\n\n/**\n * Computes the set difference of two sets (subtracts B from A): <code>C = A \\ B</code>.  This is also known as the \"relative complement\".\n *\n * @name Set.difference\n * @function\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @param set1 - A the set to be subtracted from\n * @param set2 - B the set whose elements will be subtracted from A\n * @returns {ExtendedSet|*} A new Set with all elements of A minus the elements of B\n */\nfunction difference (set1, set2) {\n  checkSet(set1)\n  checkSet(set2)\n  const set3 = new Set([])\n  set1.forEach(value => {\n    if (!set2.has(value)) {\n      set3.add(value)\n    }\n  })\n  return set3\n}\n\nglobal.Set.difference = difference\n\n/**\n * Computes the complement of set B where U is the universe: <code>C = U \\ B</code>.  This is also known as the \"absolute complement\".\n *\n * @name Set.complement\n * @function\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @throws Throws an error if any element in B does not occur in U.\n * @param set1 - U the set to be subtracted from\n * @param set2 - B the set whose elements will be subtracted from A\n * @returns {ExtendedSet|*} A new Set with all elements of U minus the elements of B\n */\nfunction complement (set1, set2) {\n  checkSet(set1)\n  checkSet(set2)\n  if (!set1.isSupersetOf(set2)) {\n    throw new Error(`[set2] has an element which is not in the universe [set1].`)\n  }\n  return Set.difference(set1, set2)\n}\n\nglobal.Set.complement = complement\n\n/**\n *\n * @private\n */\nfunction symDiff (set1, set2) {\n  const set3 = new Set()\n\n  function addToSet (source, compare, target) {\n    source.forEach(value => {\n      if (!compare.has(value)) {\n        target.add(value)\n      }\n    })\n  }\n\n  addToSet(set1, set2, set3)\n  addToSet(set2, set1, set3)\n  return set3\n}\n\n/**\n * Creates the symmetric difference (disjunctive union) of an arbitrary number (2 .. n) of sets.\n * The symmetric difference of two sets A and B is a set, that contains only those elements,\n * which are in either of the sets and not in their intersection.\n * The symmetric difference is commutative and associative, which is why arbitrary number of sets can be used as input\n * for a sequencial-computed symmetric difference.\n * <br>\n * Expression: <code>C = A Δ B</code>\n *\n * @function\n * @name Set.symDiff\n * @param args {...Set}- An arbitrary amount of Set instances\n * @example\n * const a = Set.from(1,2,3)\n * const b = Set.from(3,4)\n * Set.symDiff(a, b) // Set { 1, 2, 4 }\n * @throws Throws an error if any of the given arguments is not a set instance.\n * @returns {Set} Returns a new Set, that contains only elements.\n * @see https://en.wikipedia.org/wiki/Symmetric_difference\n */\nfunction symmetricDifference (...args) {\n  args.forEach(arg => checkSet(arg))\n\n  if (args.length === 2) {\n    return symDiff(...args)\n  }\n\n  let set3 = symDiff(args.shift(), args.shift())\n  while (args.length > 0) {\n    set3 = symDiff(set3, args.shift())\n  }\n  return set3\n}\n\nglobal.Set.symDiff = symmetricDifference\n\n/**\n * Creates the cartesian product of two given sets.\n * The cartesian product of two sets A and B is the set of all ordered pairs (a, b) where a ∈ A and b ∈ B.\n * <br>\n * Expression: <code>C = A x B = { (a, b) | a ∈ A and b ∈ B}</code>\n * <br>\n * Note, that <code>A x B ≠ B x A</code> (not commutative)\n * @function\n * @name Set.cartesian\n * @param set1 {Set} - A set instance\n * @param set2 {Set} - A set instance\n * @example\n * const a = Set.from(1,2)\n * const b = Set.from(3,4)\n * Set.cartesian(a, b) // Set { [1, 3], [1, 4], [2, 3], [2, 4] }\n * Set.cartesian(b, a) // Set { [3, 1], [3, 2], [4, 1], [4, 2] }\n * @throws Throws an error unless both arguments are set instances.\n * @return {Set} a new set instance, that contains the ordered element pairs.\n * @see https://en.wikipedia.org/wiki/Cartesian_product\n */\nglobal.Set.cartesian = function cartesianProduct (set1, set2) {\n  checkSet(set1)\n  checkSet(set2)\n  const set3 = new Set()\n  set1.forEach(value1 => set2.forEach(value2 => set3.add([value1, value2])))\n  return set3\n}\n\n/**\n * https://en.wikipedia.org/wiki/Power_set\n * @private\n */\nfunction addToSubset (e, T) {\n  T.forEach(X => X.add(e))\n  return T\n}\n\n/**\n * https://en.wikipedia.org/wiki/Power_set\n * @private\n */\nfunction subsets (S) {\n  checkSet(S)\n  if (S.size === 0) {\n    return Set.from(S)\n  }\n\n  const e = S.any()\n  let T = Set.difference(S, Set.from(e))\n  const PT = subsets(T)\n  const PTe = addToSubset(e, subsets(T))\n  return Set.union(PT, PTe)\n}\n\n/**\n * Creates the powerset of a given set instance by using a recursive algorithm (see <a href=\"https://en.wikipedia.org/wiki/Power_set\">Wikipedia</a>, section Algorithms).\n * The powerset of a set contains all possible subsets of the set, plus itself and the empty set.\n * <br>\n * <strong>Attention:</strong> This method grows exponentially with the size of the given set.\n * @name Set.power\n * @function\n * @param set {Set} - A Set instance.\n * @throws\n * Throws an error if the given set is not a set instance.\n * @returns {Set} a new set instance with all subsets of the given set, plus the given set itself and the empty set.\n * @see https://en.wikipedia.org/wiki/Power_set\n */\nfunction powerSet (set) {\n  checkSet(set)\n\n  const subs = subsets(set)\n  subs.add(new Set())\n  set.forEach(value => subs.add(Set.from(value)))\n  return subs\n}\n\nglobal.Set.power = powerSet\n\n/**\n * Merges two rules functions with a strict pass concept.\n * The resulting function requires the given element to pass at least one of the given functions (logical OR).\n * @function\n * @name Set.mergeRules\n * @throws Throws an error if any of the given parameters is not a Function\n * @param rules {...Function} - An arbitrary amount of (rules-) functions. See {@link Set.prototype.rules} for requirements of a rules function.\n * @returns {function(*=): boolean} The resulting rules function that can be attached to a set instance.\n * @see Set.prototype.rules\n *\n */\nfunction mergeRules (...rules) {\n  checkRules(rules)\n  return value => {\n    let passed = rules.some(rule => rule.call(value))\n    if (!passed) {\n      throw new Error(`Value [${value}] does not match any rule of the ruleset.`)\n    }\n    return true\n  }\n}\n\nglobal.Set.mergeRules = mergeRules\n\n/**\n * Merges two rules functions with a strict pass concept.\n * The resulting function requires the given element to pass all of the given functions (logical AND).\n * Thus, if the element fails one, it fails all.\n * <strong>Attention:</strong> If passed rules are mutually exclusive, none given element will pass the test in any circumstance.\n * @function\n * @name Set.mergeRulesStrict\n * @throws Throws an error if any of the given parameters is not a Function\n * @param rules {...Function} - An arbitrary amount of (rules-) functions. See {@link Set.prototype.rules} for requirements of a rules function.\n * @returns {function(*=): boolean} The resulting rules function that can be attached to a set instance.\n * @see Set.prototype.rules\n */\nfunction mergeRulesStrict (...rules) {\n  checkRules(rules)\n  return value => {\n    let passed = rules.every(rule => rule.call(value))\n    if (!passed) {\n      throw new Error(`Value [${value}] does not match any rule of the ruleset.`)\n    }\n    return true\n  }\n}\n\nglobal.Set.mergeRulesStrict = mergeRulesStrict\n"],"file":"index.js"}