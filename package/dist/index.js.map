{"version":3,"sources":["../lib/index.js"],"names":["checkRules","rules","forEach","rule","Error","value","checkSet","set","constructor","global","Set","checkSets","sets","checkArgsSingle","args","length","arbitraryToBinary","arbitraryFunc","binaryFunc","_originalAdd","prototype","add","rulesFct","call","originalHas","has","resolve","obj","circ","_originalSet","fctObj","fctStr","String","replace","refs","Object","getOwnPropertyNames","map","key","isArray","Array","el","copy","sort","a","b","localeCompare","valType","iterator","values","element","next","elType","setCompare","equal","sortedElmnt","sortedValue","JSON","stringify","toArray","self","out","size","count","any","isSupersetOf","isSubsetOf","isProperSupersetOf","properSupersetOf","isProperSubsetOf","properSubsetOf","ExtendedSet","elements","original","from","toSet","c","unionArbitrary","set3","union","intersect","arg","every","compare","difference","set1","set2","complement","symDiff","addToSet","source","target","symmetricDifference","shift","cartesian","cartesianProduct","value1","value2","addToSubset","e","T","X","subsets","S","PT","PTe","powerSet","subs","power","mergeRules","passed","some","mergeRulesStrict"],"mappings":"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","sourcesContent":["// //////////////////////////////////////////////////////////////////////////////// //\n// MIT License\n//\n// Copyright (c) 2018 Jan Küster\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n//   The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n// //////////////////////////////////////////////////////////////////////////////// //\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// INTERNAL                                                                         //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * @private\n */\nfunction checkRules (rules) {\n  rules.forEach(rule => {\n    if (typeof rule !== 'function') {\n      throw new Error(`Expected [rule] to be typeof [function], got [${typeof value}]`)\n    }\n  })\n  return true\n}\n\n/**\n * @private\n */\nfunction checkSet (set) {\n  if (!set || !set.constructor || !(set instanceof global.Set)) {\n    throw new Error(`Expected [set] to be instanceof [Set], got [${set && set.constructor}]`)\n  }\n  return true\n}\n\n/**\n * @private\n */\nfunction checkSets (sets) {\n  sets.forEach(set => checkSet(set))\n  return true\n}\n\n/**\n * @private\n */\nfunction checkArgsSingle (args) {\n  if (!args || args.length !== 1) {\n    throw new Error(`The function must be given exactly 1 argument.`)\n  }\n  return true\n}\n\n/**\n * A decorator which, given an arbitrary set function, produces the corresponding binary operation.\n * @private\n */\nfunction arbitraryToBinary (arbitraryFunc) {\n  return function binaryFunc (...args) {\n    checkArgsSingle(args)\n    const set = args[0]\n    checkSet(set)\n    return arbitraryFunc(this, set)\n  }\n}\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// OVERRIDES                                                                        //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * The original add function.\n * @private\n */\nconst _originalAdd = global.Set.prototype.add\n\n/**\n * Adds a value to the set. If the set already contains the value, nothing happens.\n * Overrides Set.prototype.add.\n * @name Set.prototype.add\n * @function\n * @throws Error if rules function exists and {value} failed the rules check.\n * @param value {*}- Required. Any arbitrary value to be added to the set.\n * @returns {Set} the Set object\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add\n */\nfunction add (value) {\n  if (this.rulesFct && !this.rulesFct.call(null, value)) {\n    throw new Error(`Value [${value}] does not match ruleset.`)\n  }\n  return _originalAdd.call(this, value)\n}\n\nglobal.Set.prototype.add = add\n\n/**\n * The original has function reference.\n * @private\n */\nconst originalHas = global.Set.prototype.has\n\n/**\n * Resolves an element's inner structure to make it comparable by JSON.stringify.\n * @private\n */\nfunction resolve (obj, circ = new _originalSet([obj])) {\n  if (typeof obj === 'undefined' ||\n    typeof obj === 'string' ||\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    obj === null) {\n    return obj\n  }\n\n  if (typeof obj === 'function') {\n    const fctObj = { fctStr: String(obj).replace(/\\s+/g, '') } // function body to string\n    // resolve all function properties / attached references\n    fctObj.refs = Object.getOwnPropertyNames(obj).map(key => originalHas.call(circ, obj[key]) ? 'circular' : resolve(obj[key], circ))\n    return fctObj\n  }\n\n  const isArray = Array.isArray(obj)\n  if (typeof obj !== 'object' && !isArray) {\n    return obj\n  }\n\n  // add obj to check for\n  // circular references\n  circ.add(obj)\n\n  if (isArray) {\n    return obj.map(el => originalHas.call(circ, el) ? 'circular' : resolve(el, circ))\n  }\n\n  const copy = {}\n  Object.getOwnPropertyNames(obj)\n    .sort((a, b) => a.localeCompare(b))\n    .forEach(key => {\n      copy[key] = originalHas.call(circ, obj[key]) ? 'circular' : resolve(obj[key], circ)\n    })\n  return copy\n}\n\n/**\n * Checks if the current set instance contains a given value by recursive deep compare.\n * Overrides the original Set.prototype.has.\n * The check is recursive and respects\n * <ul>\n *   <li>primitive types</li>\n *   <li>complex types, such as Objects or Arrays</li>\n *   <li>nested Objects and cyclic references</li>\n *   <li>functions</li>\n *   <li>functions with properties attached</li>\n *   <li>sets, sets of sets</li>\n * </ul>\n *\n * Note, that functions will be checked against their whitespace-trimmed bodies, which can return false negatives,\n * if for example a comment is added to the compare function that not exists in the original function.\n *\n * @function\n * @name Set.prototype.has\n * @example\n * const a = Set.from({ a:true, b:false })\n * a.has({ b:false, a:true })  // true\n * a.has({ b:false, a:false }) // false\n * @param value {*} - The value to be checked.\n * @returns {boolean} - True, if the value is contained by the set. False, if otherwise.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has\n */\nglobal.Set.prototype.has = function has (value) {\n  const valType = typeof value\n  if (valType === 'string' || valType === 'number' || valType === 'boolean') {\n    return originalHas.call(this, value)\n  }\n\n  const iterator = this.values()\n  let element\n  while ((element = iterator.next().value) !== void 0) {\n    const elType = typeof element\n\n    if (elType !== valType) {\n      return false\n    }\n\n    const setCompare = (element instanceof Set && value instanceof Set)\n\n    // if both point to the same reference\n    if (element === value) {\n      return true\n    } else\n\n    // if we want to check if this set has a set with the\n    // same elements as the given set in the argument,\n    // we need to check for equality of all elements of this set\n    // and the argument set\n    if (setCompare && element.equal(value)) {\n      return true\n    } else\n\n    // - if we want to check if ordered pairs (represented as arrays),\n    //   are equal, we resolve their children and compare their strings.\n    // - For all nested objects we recursively create a \"sorted\"\n    //   version of both and compare their strings.\n    // - functions are string-ed and their properties are resolved\n    //   like objects\n    if ((elType === 'function' && valType === 'function') ||\n      (!setCompare && elType === 'object' && valType === 'object') ||\n      (Array.isArray(element) && Array.isArray(value))) {\n      const sortedElmnt = resolve(element)\n      const sortedValue = resolve(value)\n\n      if (JSON.stringify(sortedElmnt) === JSON.stringify(sortedValue)) {\n        return true\n      }\n    }\n  }\n\n  // and if nothing has matched, we assume\n  // that it is not contained in this set\n  return false\n}\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// PROTOTYPES                                                                       //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * Pass a function that dictates the rules for elements to be part of this set.\n * Use without args to get the current rules function.\n * <br>\n * A rules function needs to fulfill the following requirements:\n * <ul>\n *   <li>Obtain a single element as argument</li>\n *   <li>Check, if that element passes certain conditions</li>\n *   <li>Return false if the element fails any condition</li>\n *   <li>Otherwise return true</li>\n * </ul>\n * <br>\n * If a set contains a rules function (or a merge of many rules functions), the element will only be added to the set,\n * if it passes the rules check.\n * @function\n * @name Set.prototype.rules\n * @example\n * const isInt = n => Number.isInteger(n)\n * const integers = Set.from()\n * integers.rules(isInt)\n * integers.add(1)   // OK, no error\n * integers.add(1.5) // throws error!\n * integers.add(1.0) // OK, because 1.0 === 1 in JS Number\n * @param value {Function} (Optional) a Function that obtains a single argument and returns either a truthy or falsey value.\n * @returns {Function|undefined} Returns the current rules Function or undefined if there is on rules function assigned.\n */\nfunction rules (value) {\n  if (value) {\n    checkRules([value])\n    this.rulesFct = value\n  }\n  return this.rulesFct\n}\n\nglobal.Set.prototype.rules = rules\n\n/**\n * Creates an (unsorted) array from all elements of this set.\n * @function\n * @name Set.prototype.toArray\n * @example new Set([1, 2, 3, 4]).toArray() // [ 1, 2, 3, 4 ]\n * @returns {Array} Array containing all elements of this set in unsorted order.\n */\nfunction toArray () {\n  const self = this\n  const out = []\n  out.length = self.size\n  let count = 0\n  self.forEach(value => {\n    out[count++] = value\n  })\n  return out\n}\n\nglobal.Set.prototype.toArray = toArray\n\n/**\n * Returns an arbitrary element of this collection.\n * Basically the first element, retrieved by iterator.next().value will be used.\n * @function\n * @name Set.prototype.any\n * @returns {*} An arbitrary element of the current set that could by of any type, depending on the elements of the set.\n */\nfunction any () {\n  const self = this\n  const iterator = self.values()\n  return iterator.next().value\n}\n\nglobal.Set.prototype.any = any\n\n/**\n * Checks, whether the current set (this) is a superset of the given set.\n * A set A is superset of set B, if A contains all elements of B.\n * <br>\n * Expression: <code>A ⊇ B</code>\n * @function\n * @name Set.prototype.isSupersetOf\n * @example\n * const a = Set.from(1,2,3,4)\n * const b = Set.from(1,2,3)\n * const c = Set.from(1,2,3,4,5)\n * a.isSupersetOf(b) // true\n * a.isSupersetOf(c) // false\n * c.isSupersetOf(b) // true\n * @param set {Set} - A set instance of which this set is checked to be the superset.\n * @throws Throws an error, if the given set is not a set instance.\n * @returns {boolean} true if this set is the superset of the given set, otherwise false.\n * @see https://en.wikipedia.org/wiki/Subset\n */\nfunction isSupersetOf (set) {\n  const iterator = set.values()\n  let value\n  while ((value = iterator.next().value) !== void 0) {\n    if (!this.has(value)) return false\n  }\n  return true\n}\n\nglobal.Set.prototype.isSupersetOf = isSupersetOf\n\n/**\n * Checks, whether the current set (this) is a subset of the given set.\n * A set A is subset of set B, if B contains all elements of A.\n * <br>\n * Expression: <code>A ⊆ B</code>\n * <br>\n * If their sizes are also equal, they can be assumed as equal.\n * If their sizes are not equal, then A is called a proper subset of B.\n * @function\n * @name Set.prototype.isSubsetOf\n * @example\n * const a = Set.from(1,2,3,4)\n * const b = Set.from(1,2,3)\n * const c = Set.from(1,2,3,4,5)\n * a.isSubsetOf(b) // false\n * b.isSubsetOf(c) // true\n * c.isSubsetOf(a) // false\n * @param set {Set} - A set instance of which this set is checked to be the subset.\n * @throws Throws an error, if the given set is not a set instance.\n * @returns {boolean} - true if this set is the subset of the given set, false otherwise\n * @see https://en.wikipedia.org/wiki/Subset\n * @see Set.prototype.equal\n * @see Set.prototype.isProperSubsetOf\n */\nfunction isSubsetOf (set) {\n  return set.isSupersetOf(this)\n}\n\nglobal.Set.prototype.isSubsetOf = isSubsetOf\n\n/**\n * Checks, whether the current set (this) is a proper superset of the given set.\n * A set A is a proper subset of set B, if A contains all elements of B and their sizes are not equal.\n * <br>\n * Expression: <code>A ⊃ B</code>\n * @function\n * @name Set.prototype.properSupersetOf\n * @param set {Set} - A set instance of which this set is checked to be the proper superset.\n * @returns {boolean}\n * @see https://en.wikipedia.org/wiki/Subset\n */\nfunction isProperSupersetOf (set) {\n  return this.size !== set.size && this.isSupersetOf(set)\n}\n\nglobal.Set.prototype.properSupersetOf = isProperSupersetOf\n\n/**\n * Checks, whether the current set (this) is a proper subset of the given set.\n * A set A is a proper subset of set B, if B contains all elements of A and their sizes are not equal.\n * <br>\n * Expression: <code>A ⊂ B</code>\n * @function\n * @name Set.prototype.properSupersetOf\n * @param set {Set} - A set instance of which this set is checked to be the proper subset.\n * @returns {boolean}\n * @see https://en.wikipedia.org/wiki/Subset\n */\nfunction isProperSubsetOf (set) {\n  return this.size !== set.size && this.isSubsetOf(set)\n}\n\nglobal.Set.prototype.properSubsetOf = isProperSubsetOf\n\n/**\n * Checks, whether two sets are equal in terms of their contained elements.\n * Note: This implementation uses a deep object comparison in order to check for \"sameness\".\n * This allows also to check equality for more complex / nested structures without the restriction of interpreting\n * \"sameness\" as \"being the exact same instance\". If such an equality is desired, please use Set.prototype.equalSrict\n * @function\n * @name Set.prototype.equal\n * @example\n * const a = Set.from(1,2,3)\n * const b = Set.from(1,2,3.0) // note that 3.0 will evaluate to 3 here!\n * a === b    // false\n * a.equal(b) // true\n * @example\n * const a = Set.from({ a:true, b:false })\n * const b = Set.from({ b:false, a:true })\n * a.equal(b) // true\n * @param set {Set} - A set instance, which this set is to be compared with.\n * @throws Throws an error if the given paramter is not a Set instance.\n * @returns {boolean} true, if all elements of this set equal to the elements of the given set.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness\n * @see Set.prototype.isSubsetOf\n */\nfunction equal (set) {\n  checkSet(set)\n  if (this.size !== set.size) {\n    return false\n  }\n  return this.isSubsetOf(set)\n}\n\nglobal.Set.prototype.equal = equal\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// CONSTRUCTOR                                                                      //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * The original Set reference.\n * @private\n */\nconst _originalSet = global.Set\n\n/**\n * Use <code>new Set(elements, rulesFct)</code> to create new sets. Alternatively you can use <code>Set.from</code>\n * @class\n * @name Set\n * @classdesc Extended version of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">Set (MDN link)</a>\n * @param elements {array} - an Array of element.\n * @param rulesFct {function} - a function which every element added to the set needs to pass.\n * @see Set.from\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n * @returns {Set} An instance of the extended version of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">Set (MDN link)</a>\n */\nfunction ExtendedSet (elements, rulesFct) {\n  const original = new _originalSet()\n  if (rulesFct) {\n    original.rules(rulesFct)\n  }\n  if (elements) { elements.forEach(element => original.add(element)) }\n  return original\n}\n\nglobal.Set = ExtendedSet\nglobal.Set.prototype = _originalSet.prototype\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// STATICS                                                                          //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * Creates a new Set from arbitrary arguments without the need of \"new\" and the array notation.\n * @function\n * @name Set.from\n * @example Set.from(1,2,3,4,5) // returns Set { 1, 2, 3, 4, 5 }\n * @example\n * const ints = Set.from(1,2,3)\n * const flts = Set.from(4.5, 5.6, 6.7)\n * Set.from(ints, flts) // returns Set { Set {1, 2, 3}, Set { 4.5, 5.6, 6.7 } }\n * @param args {...*} - values of any types / length (using comma notation or spread operator)\n * @returns {Set} A set containing the given argument values.\n */\nfunction from (...args) {\n  return new Set([...args])\n}\n\nglobal.Set.from = from\n\n/**\n * Autowraps a value to a Set, unless it is already a Set.\n * @function\n * @name Set.toSet\n * @param value  {*} - Any arbitrary value\n * @returns {Set} A Set containing the value or the value if it is already a Set.\n */\nfunction toSet (value) {\n  return value instanceof Set ? value : Set.from(value)\n}\n\nglobal.Set.toSet = toSet\n\n/**\n * Copies all elements of a given Set instance into a new Set and returns it.\n * <strong>It does not deep-clone the elements of the set.</strong>\n * @function\n * @name Set.copy\n * @throws Throws an error if the argument is not a Set instance.\n * @param set {Set} a set instance from which to copy from\n * @returns {Set} a new Set instance containing all elements of the source.\n */\nfunction copy (set) {\n  checkSet(set)\n  const c = new Set()\n  set.forEach(el => c.add(el))\n  return c\n}\n\nglobal.Set.copy = copy\n\n/**\n * Creates the set union of an arbitrary number of sets.\n * The union S of an iterable M of sets M<sub>i</sub> is the set that consists of all elements of each M<sub>i</sub>.\n * <br>Expression: <code>∪ M = S</code>\n * <br>Example: <code>∪ {A, B, C} = S</code>\n * <br>Example: <code>∪ {{0,4}, {1}, {9}} = {0,1,4,9}</code>\n * @example\n * const A = Set.from(0, 4)\n * const B = Set.from(1)\n * const C = Set.from(9)\n * Set.union(A, B, C) // Set { 0, 1, 4, 9 }\n * const M = [A, B, C]\n * Set.union(...M) // Set { 0, 1, 4, 9 }\n * @name Set.union\n * @function\n * @param args {...Set} - an arbitrary list of Set instances\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @returns {Set} a Set instance with the unified elements of the given args.\n * @see https://en.wikipedia.org/wiki/Union_(set_theory)#Arbitrary_unions\n */\nfunction unionArbitrary (...args) {\n  checkSets(args)\n  const set3 = new Set()\n  args.forEach(set => set.forEach(value => set3.add(value)))\n  return set3\n}\nglobal.Set.union = unionArbitrary\n\n/**\n * Creates the set union of two sets.\n * The union of A and B is the set C that consists of all elements of A and B.\n * <br>Expression: <code>A ∪ B = C</code>\n * <br>Example: <code>{1,2} ∪ {1,7,8,9} = {1,2,7,8,9}</code>\n * @example\n * const A = Set.from(1, 2)\n * const B = Set.from(1, 7, 8, 9)\n * A.union(B) // Set { 1, 2, 7, 8, 9 }\n * @name Set.prototype.union\n * @function\n * @param args {set} - the other set to union with.\n * @throws Throws an error if there is not exactly one argument.\n * @throws Throws an error if the argument is not a Set instance.\n * @returns {Set} a Set instance with the unified elements of the given args.\n * @see https://en.wikipedia.org/wiki/Union_(set_theory)#Union_of_two_sets\n */\nglobal.Set.prototype.union = arbitraryToBinary(unionArbitrary)\n\n/**\n * Creates an intersection set of an arbitrary number of sets.\n * An intersection is a set of A and B, which contains all elements that appear in A, as well as in B.\n * <br>\n * Expression: <code>C = A ∩ B</code>\n * <br>\n * Example: <code>{1, 2, 3} ∩ {2, 3, 4} = {2, 3}.</code>\n * @name Set.intersect\n * @function\n * @param args {...Set}- an arbitrary list of Set instances\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @returns {Set} a Set instance with the unified elements of the given args.\n * @see https://en.wikipedia.org/wiki/Intersection_(set_theory)\n */\nfunction intersect (...args) {\n  args.forEach(arg => checkSet(arg))\n  const set3 = new Set([])\n  args.forEach(set => {\n    set.forEach(value => {\n      if (args.every(compare => compare.has(value))) {\n        set3.add(value)\n      }\n    })\n  })\n  return set3\n}\n\nglobal.Set.intersect = intersect\n\n/**\n * Computes the set difference of two sets (subtracts B from A): <code>C = A \\ B</code>.  This is also known as the \"relative complement\".\n *\n * @name Set.difference\n * @function\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @param set1 - A the set to be subtracted from\n * @param set2 - B the set whose elements will be subtracted from A\n * @returns {ExtendedSet|*} A new Set with all elements of A minus the elements of B\n */\nfunction difference (set1, set2) {\n  checkSet(set1)\n  checkSet(set2)\n  const set3 = new Set([])\n  set1.forEach(value => {\n    if (!set2.has(value)) {\n      set3.add(value)\n    }\n  })\n  return set3\n}\n\nglobal.Set.difference = difference\n\n/**\n * Computes the complement of set B where U is the universe: <code>C = U \\ B</code>.  This is also known as the \"absolute complement\".\n *\n * @name Set.complement\n * @function\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @throws Throws an error if any element in B does not occur in U.\n * @param set1 - U the set to be subtracted from\n * @param set2 - B the set whose elements will be subtracted from A\n * @returns {ExtendedSet|*} A new Set with all elements of U minus the elements of B\n */\nfunction complement (set1, set2) {\n  checkSet(set1)\n  checkSet(set2)\n  if (!set1.isSupersetOf(set2)) {\n    throw new Error(`[set2] has an element which is not in the universe [set1].`)\n  }\n  return Set.difference(set1, set2)\n}\n\nglobal.Set.complement = complement\n\n/**\n *\n * @private\n */\nfunction symDiff (set1, set2) {\n  const set3 = new Set()\n\n  function addToSet (source, compare, target) {\n    source.forEach(value => {\n      if (!compare.has(value)) {\n        target.add(value)\n      }\n    })\n  }\n\n  addToSet(set1, set2, set3)\n  addToSet(set2, set1, set3)\n  return set3\n}\n\n/**\n * Creates the symmetric difference (disjunctive union) of an arbitrary number (2 .. n) of sets.\n * The symmetric difference of two sets A and B is a set, that contains only those elements,\n * which are in either of the sets and not in their intersection.\n * The symmetric difference is commutative and associative, which is why arbitrary number of sets can be used as input\n * for a sequencial-computed symmetric difference.\n * <br>\n * Expression: <code>C = A Δ B</code>\n *\n * @function\n * @name Set.symDiff\n * @param args {...Set}- An arbitrary amount of Set instances\n * @example\n * const a = Set.from(1,2,3)\n * const b = Set.from(3,4)\n * Set.symDiff(a, b) // Set { 1, 2, 4 }\n * @throws Throws an error if any of the given arguments is not a set instance.\n * @returns {Set} Returns a new Set, that contains only elements.\n * @see https://en.wikipedia.org/wiki/Symmetric_difference\n */\nfunction symmetricDifference (...args) {\n  args.forEach(arg => checkSet(arg))\n\n  if (args.length === 2) {\n    return symDiff(...args)\n  }\n\n  let set3 = symDiff(args.shift(), args.shift())\n  while (args.length > 0) {\n    set3 = symDiff(set3, args.shift())\n  }\n  return set3\n}\n\nglobal.Set.symDiff = symmetricDifference\n\n/**\n * Creates the cartesian product of two given sets.\n * The cartesian product of two sets A and B is the set of all ordered pairs (a, b) where a ∈ A and b ∈ B.\n * <br>\n * Expression: <code>C = A x B = { (a, b) | a ∈ A and b ∈ B}</code>\n * <br>\n * Note, that <code>A x B ≠ B x A</code> (not commutative)\n * @function\n * @name Set.cartesian\n * @param set1 {Set} - A set instance\n * @param set2 {Set} - A set instance\n * @example\n * const a = Set.from(1,2)\n * const b = Set.from(3,4)\n * Set.cartesian(a, b) // Set { [1, 3], [1, 4], [2, 3], [2, 4] }\n * Set.cartesian(b, a) // Set { [3, 1], [3, 2], [4, 1], [4, 2] }\n * @throws Throws an error unless both arguments are set instances.\n * @return {Set} a new set instance, that contains the ordered element pairs.\n * @see https://en.wikipedia.org/wiki/Cartesian_product\n */\nglobal.Set.cartesian = function cartesianProduct (set1, set2) {\n  checkSet(set1)\n  checkSet(set2)\n  const set3 = new Set()\n  set1.forEach(value1 => set2.forEach(value2 => set3.add([value1, value2])))\n  return set3\n}\n\n/**\n * https://en.wikipedia.org/wiki/Power_set\n * @private\n */\nfunction addToSubset (e, T) {\n  T.forEach(X => X.add(e))\n  return T\n}\n\n/**\n * https://en.wikipedia.org/wiki/Power_set\n * @private\n */\nfunction subsets (S) {\n  checkSet(S)\n  if (S.size === 0) {\n    return Set.from(S)\n  }\n\n  const e = S.any()\n  let T = Set.difference(S, Set.from(e))\n  const PT = subsets(T)\n  const PTe = addToSubset(e, subsets(T))\n  return Set.union(PT, PTe)\n}\n\n/**\n * Creates the powerset of a given set instance by using a recursive algorithm (see <a href=\"https://en.wikipedia.org/wiki/Power_set\">Wikipedia</a>, section Algorithms).\n * The powerset of a set contains all possible subsets of the set, plus itself and the empty set.\n * <br>\n * <strong>Attention:</strong> This method grows exponentially with the size of the given set.\n * @name Set.power\n * @function\n * @param set {Set} - A Set instance.\n * @throws\n * Throws an error if the given set is not a set instance.\n * @returns {Set} a new set instance with all subsets of the given set, plus the given set itself and the empty set.\n * @see https://en.wikipedia.org/wiki/Power_set\n */\nfunction powerSet (set) {\n  checkSet(set)\n\n  const subs = subsets(set)\n  subs.add(new Set())\n  set.forEach(value => subs.add(Set.from(value)))\n  return subs\n}\n\nglobal.Set.power = powerSet\n\n/**\n * Merges two rules functions with a strict pass concept.\n * The resulting function requires the given element to pass at least one of the given functions (logical OR).\n * @function\n * @name Set.mergeRules\n * @throws Throws an error if any of the given parameters is not a Function\n * @param rules {...Function} - An arbitrary amount of (rules-) functions. See {@link Set.prototype.rules} for requirements of a rules function.\n * @returns {function(*=): boolean} The resulting rules function that can be attached to a set instance.\n * @see Set.prototype.rules\n *\n */\nfunction mergeRules (...rules) {\n  checkRules(rules)\n  return value => {\n    let passed = rules.some(rule => rule.call(value))\n    if (!passed) {\n      throw new Error(`Value [${value}] does not match any rule of the ruleset.`)\n    }\n    return true\n  }\n}\n\nglobal.Set.mergeRules = mergeRules\n\n/**\n * Merges two rules functions with a strict pass concept.\n * The resulting function requires the given element to pass all of the given functions (logical AND).\n * Thus, if the element fails one, it fails all.\n * <strong>Attention:</strong> If passed rules are mutually exclusive, none given element will pass the test in any circumstance.\n * @function\n * @name Set.mergeRulesStrict\n * @throws Throws an error if any of the given parameters is not a Function\n * @param rules {...Function} - An arbitrary amount of (rules-) functions. See {@link Set.prototype.rules} for requirements of a rules function.\n * @returns {function(*=): boolean} The resulting rules function that can be attached to a set instance.\n * @see Set.prototype.rules\n */\nfunction mergeRulesStrict (...rules) {\n  checkRules(rules)\n  return value => {\n    let passed = rules.every(rule => rule.call(value))\n    if (!passed) {\n      throw new Error(`Value [${value}] does not match any rule of the ruleset.`)\n    }\n    return true\n  }\n}\n\nglobal.Set.mergeRulesStrict = mergeRulesStrict\n"],"file":"index.js"}